import { Algorithm } from '@/types/algorithm';

export const algorithms: Algorithm[] = [
  // Sorting Algorithms
  {
    id: 'bubble-sort',
    name: 'Bubble Sort',
    category: 'sorting',
    description: 'Repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.',
    timeComplexity: 'O(n²)',
    spaceComplexity: 'O(1)',
    pseudocode: [
      'for i from 0 to n-1:',
      '  for j from 0 to n-i-1:',
      '    if arr[j] > arr[j+1]:',
      '      swap arr[j] and arr[j+1]',
    ],
  },
  {
    id: 'selection-sort',
    name: 'Selection Sort',
    category: 'sorting',
    description: 'Divides input into sorted and unsorted regions, repeatedly selecting the smallest element from unsorted region.',
    timeComplexity: 'O(n²)',
    spaceComplexity: 'O(1)',
    pseudocode: [
      'for i from 0 to n-1:',
      '  min_idx = i',
      '  for j from i+1 to n:',
      '    if arr[j] < arr[min_idx]:',
      '      min_idx = j',
      '  swap arr[i] and arr[min_idx]',
    ],
  },
  {
    id: 'insertion-sort',
    name: 'Insertion Sort',
    category: 'sorting',
    description: 'Builds final sorted array one item at a time by inserting elements into their correct position.',
    timeComplexity: 'O(n²)',
    spaceComplexity: 'O(1)',
    pseudocode: [
      'for i from 1 to n:',
      '  key = arr[i]',
      '  j = i - 1',
      '  while j >= 0 and arr[j] > key:',
      '    arr[j+1] = arr[j]',
      '    j = j - 1',
      '  arr[j+1] = key',
    ],
  },
  {
    id: 'merge-sort',
    name: 'Merge Sort',
    category: 'sorting',
    description: 'Divide and conquer algorithm that divides array into halves, sorts them and merges them back.',
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    pseudocode: [
      'function mergeSort(arr):',
      '  if length of arr <= 1:',
      '    return arr',
      '  mid = length / 2',
      '  left = mergeSort(arr[0...mid])',
      '  right = mergeSort(arr[mid...end])',
      '  return merge(left, right)',
    ],
  },
  {
    id: 'quick-sort',
    name: 'Quick Sort',
    category: 'sorting',
    description: 'Selects a pivot element and partitions array around it, then recursively sorts sub-arrays.',
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(log n)',
    pseudocode: [
      'function quickSort(arr, low, high):',
      '  if low < high:',
      '    pivot = partition(arr, low, high)',
      '    quickSort(arr, low, pivot-1)',
      '    quickSort(arr, pivot+1, high)',
    ],
  },
  {
    id: 'heap-sort',
    name: 'Heap Sort',
    category: 'sorting',
    description: 'Builds a max heap and repeatedly extracts the maximum element to build sorted array.',
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(1)',
    pseudocode: [
      'buildMaxHeap(arr)',
      'for i from n-1 to 1:',
      '  swap arr[0] and arr[i]',
      '  heapify(arr, 0, i)',
    ],
  },

  // Graph Algorithms
  {
    id: 'bfs',
    name: 'Breadth-First Search',
    category: 'graph',
    description: 'Explores graph level by level using a queue, visiting all neighbors before going deeper.',
    timeComplexity: 'O(V + E)',
    spaceComplexity: 'O(V)',
    pseudocode: [
      'create queue Q',
      'mark start as visited',
      'Q.enqueue(start)',
      'while Q is not empty:',
      '  node = Q.dequeue()',
      '  for each neighbor of node:',
      '    if not visited:',
      '      mark as visited',
      '      Q.enqueue(neighbor)',
    ],
  },
  {
    id: 'dfs',
    name: 'Depth-First Search',
    category: 'graph',
    description: 'Explores graph by going as deep as possible before backtracking, using a stack.',
    timeComplexity: 'O(V + E)',
    spaceComplexity: 'O(V)',
    pseudocode: [
      'function DFS(node):',
      '  mark node as visited',
      '  for each neighbor of node:',
      '    if not visited:',
      '      DFS(neighbor)',
    ],
  },
  {
    id: 'dijkstra',
    name: "Dijkstra's Algorithm",
    category: 'graph',
    description: 'Finds shortest path from start to all other nodes using greedy approach with priority queue.',
    timeComplexity: 'O((V + E) log V)',
    spaceComplexity: 'O(V)',
    pseudocode: [
      'dist[start] = 0',
      'for all other nodes: dist[node] = infinity',
      'create priority queue Q',
      'while Q is not empty:',
      '  u = node with minimum dist in Q',
      '  for each neighbor v of u:',
      '    alt = dist[u] + weight(u, v)',
      '    if alt < dist[v]:',
      '      dist[v] = alt',
    ],
  },
  {
    id: 'astar',
    name: 'A* Algorithm',
    category: 'graph',
    description: 'Finds shortest path using heuristic to guide search, combining actual cost and estimated cost.',
    timeComplexity: 'O(b^d)',
    spaceComplexity: 'O(b^d)',
    pseudocode: [
      'openSet = {start}',
      'gScore[start] = 0',
      'fScore[start] = heuristic(start, goal)',
      'while openSet is not empty:',
      '  current = node in openSet with lowest fScore',
      '  if current == goal: return path',
      '  for each neighbor:',
      '    tentative_g = gScore[current] + dist',
      '    if tentative_g < gScore[neighbor]:',
      '      update scores and path',
    ],
  },

  // Recursion & Backtracking
  {
    id: 'fibonacci',
    name: 'Fibonacci Number',
    category: 'recursion',
    description: 'Calculates Fibonacci numbers using recursion with memoization.',
    timeComplexity: 'O(n)',
    spaceComplexity: 'O(n)',
    pseudocode: [
      'function fib(n):',
      '  if n <= 1: return n',
      '  return fib(n-1) + fib(n-2)',
    ],
  },
  {
    id: 'n-queens',
    name: 'N-Queens Problem',
    category: 'recursion',
    description: 'Places N queens on N×N chessboard so no two queens attack each other using backtracking.',
    timeComplexity: 'O(N!)',
    spaceComplexity: 'O(N)',
    pseudocode: [
      'function solveNQueens(row, n):',
      '  if row == n: return true',
      '  for col from 0 to n:',
      '    if isSafe(row, col):',
      '      place queen at (row, col)',
      '      if solveNQueens(row+1, n):',
      '        return true',
      '      remove queen from (row, col)',
      '  return false',
    ],
  },
  {
    id: 'binary-search',
    name: 'Binary Search',
    category: 'recursion',
    description: 'Searches sorted array by repeatedly dividing search interval in half.',
    timeComplexity: 'O(log n)',
    spaceComplexity: 'O(1)',
    pseudocode: [
      'function binarySearch(arr, target, low, high):',
      '  if low > high: return -1',
      '  mid = (low + high) / 2',
      '  if arr[mid] == target: return mid',
      '  if arr[mid] > target:',
      '    return binarySearch(arr, target, low, mid-1)',
      '  else:',
      '    return binarySearch(arr, target, mid+1, high)',
    ],
  },

  // Mathematical Algorithms
  {
    id: 'sieve',
    name: 'Sieve of Eratosthenes',
    category: 'math',
    description: 'Finds all prime numbers up to n by iteratively marking multiples of each prime.',
    timeComplexity: 'O(n log log n)',
    spaceComplexity: 'O(n)',
    pseudocode: [
      'create boolean array prime[0..n] = true',
      'for p from 2 to sqrt(n):',
      '  if prime[p]:',
      '    for i from p*p to n (step p):',
      '      prime[i] = false',
    ],
  },
  {
    id: 'convex-hull',
    name: 'Graham Scan (Convex Hull)',
    category: 'math',
    description: 'Computes convex hull of a set of 2D points using stack-based approach.',
    timeComplexity: 'O(n log n)',
    spaceComplexity: 'O(n)',
    pseudocode: [
      'find point with lowest y-coordinate',
      'sort points by polar angle',
      'create stack S',
      'push first 3 points',
      'for each remaining point:',
      '  while stack has 2+ points and',
      '    makes right turn: pop',
      '  push current point',
    ],
  },
];

export const getAlgorithmsByCategory = (category: string) => {
  return algorithms.filter((algo) => algo.category === category);
};

export const getAlgorithmById = (id: string) => {
  return algorithms.find((algo) => algo.id === id);
};
